= Dialekt Parse
:imagesdir: ../images
:toc:
:toclevels: 3
:numbered:

== Přehled


Dialekt Parse je jazyk specifické domény (domain-specific language - DSL) programovacího jazyka Red, který umožňuje stručné a přesné zpracování vstupů (_input_) podle gramatických pravidel (_rules_). Obvyklé případy použití DSL Parse jsou tyto:

* *Hledání:* lokalizace zadaných vzorů;
* *Validace*: ověření shody vstupu s určitou specifikací;
* *Vyjmutí*: přefiltrování dat a agregace hodnot (e.g. scraping);
* *Modifikace*: transformace dat (vložení hodnot, odejmutí a změna shodujících se vstupů);
* *Zpracování jazyka*: použití kompilátorů, interpretů a lexikálních analyzátorů, zvláště pro DSL;
* *Kódování a dekódování*: konverze datových formátů z jednoho do druhého.

=== Použití

Parsování se invokuje funkcí `parse` s použitím jednoduché implicitní syntaxe (podrobněji viz sekce <<Extra functions>>):

----
parse <input> <rules>

<input> : jakákoli hodnota typu series! kromě image! a vector!
<rules> : hodnota typu block!, obsahující platný dialekt Parse (top-level rule)
----

Implicitně vrací `parse` hodnotu typu `logic!` jako sdělení, zda zadaná gramatická pravidla byla v úplné shodě se zadaným vstupem.

=== Základní principy

Gramatická pravidla pro parsování definují vzory, použité pro vstřebání (_consume_) vstupních řad. Základní vyhodnocovací krok dialektu Parse je pravidlo _match_, které má jeden z těchto dvou výstupů:

* Pokud se dané pravidlo shoduje, je úspěšné (it _succeeds_) a Parse (nepovinně) postoupí (_advances_) za shodující se porci vstupu i pravidla;
* Není-li shoda, pravidlo selhává (_fails_), načež Parse couvne (_backtracks_) a vrátí se k _alternativním_ pravidlům (pokud existují).

Zpracování vstupu (_parsing_) je časově nemomezená aplikace tohoto základního kroku, který je zastaven jednou z následujících dvou ukončujících podmínek:

* Neúspěšná aplikace pravidla: `parse` vrací `false`, signalizujíce neshodu;
* Úplná shoda pravidla s porovnávaným vstupem  (to jest dosažení konce zkoumané řady): `parse` vrací `true`, signalizujíce shodu.

POZOR: Není-li splněna žádná z uvedených ukončovacích podmínek, může vstoupit Parse do nekonečné smyčky.

=== Glosář

Dialekt parse je vylepšený člen rodiny formálních jazyků https://en.wikipedia.org/wiki/Parsing_expression_grammar[Parsing Expression Grammar] (PEG), odlišující se širokou sadou vlastností a hlubokou integrací s jazykem Red, avšak sdílející obecné významy základních konstrukcí a operací:

Gramatická pravidla::
    Hierarchické výrazy s prakticky neomezenou skladebností. Jejich skladba a sémantika jsou popsány v sekci <<Pravidla jazyka Parse>>.

Advancing::
    Procházení vstupní řadou postupným ověřováním shody jednotlivého elementu s gramatickými pravidly až ke konci řady nebo k výskytu neshody.

Fetching::
    Vyhledání následného uplatnitelného pravidla za úspěšnou shodou.

Alternating (v PEG popsáno jako _ordered choice_)::
    V případě výskytu neshody s pravidlem se postupně pokoušet o shodu s následujícími alternativními pravidly v témže bloku za znakem `|` ("pipe", "bar", "nebo").
Backtracking::
    Vrácení vstupu a pravidel na pozici před selháním pravidla. Ostatní změny (vedlejší účinky a úpravy vstupu či pravidel) zůstávají.

Possessive matching::
    Parsovací pravidla (hlavně <<Repetition>>) se vždycky snaží posoudit co nejvíce vstupních dat.

== Režimy parsování

Dialekt Parse nabízí jistý stupeň flexibility provedení podporou různých režimů.

=== Case-sensitivity

Implicitně má Parse shodnou sémantiku jako Red a je  case-insensitive. Vnímání velkých písmen lze umožnit upřesněním `/case` nebo vypnout/zapnout klíčovým slovem `case`.

*Syntaxe*

----
case <word>

<word> : word! value
----

S hodnotou, na níž odkazuje word se zachází jako s logickým praporkem (flag) podle standardní sémantiky Redu. Logické true umožňuje case-sensitivní režim, zatímco logické false jej znemožňuje.

=== Sběrný režim

Pravidlo `collect` přikazuje, aby `parse` vrátilo blok místo hodnoty `logic!`. Detaily lze nalézt v sekci <<Extraction>> section.

=== Typy vstupu

V závislosti na typu vstupních řad nejsou některá pravidla Parse uplatnitelná nebo se chovají odlišně.

* `any-block!`:
    ** Vyhledávání shody se sadou znaků nemá žádný význam a vždycky selže;
* `any-string!` a `binary!`:
    ** Porovnávání s datovým typem nebo se sadou typů není podporováno.

== Parsovací pravidla

Gramatická pravidla v dialektu Parse mohou mít několik forem a obvykle mají vnořenou nebo rekurzivní strukturu. Každé pravidlo je jedním z následujících:

* Dialektem rezervované _klíčové slovo_, volitelně následované argumenty nebo možnostmi (viz níže).
* Hodnota některého z následujících datových typů:
    ** `datatype!` nebo `typeset!` - porovnává vstupní hodnotu s jejím <<Datatype, typem>>;   
	** `bitset!` - reprezentuje <<Character set, znakovou sadu>>;
    ** `word!` - odkazuje na well-formed sub-rule;
    ** `lit-word!` nebo `lit-path!` — zavedené zkratky pro <<Literal value, doslovnou shodu>> vstupních hodnot typu `word!` případně `path!`;
    ** `set-word!` - se používá k <<Marking, nastavení>> slova na aktuální vstupní pozici;
    ** `get-word!` - <<Restoring, vrátí>> pozici vstupu k dříve nastavenému slovu;
    ** `block!` - hodnota, která obsahuje libovolný počet sub-pravidel a znaků `|`, jež působí jako oddělovače pro alternativní pravidla;
    ** `integer!` - hodnota, která slouží jako počítadlo pro
	value, serves as a counter for <<Iteration count, opakování>> pravidla; dvě následující hodnoty typu  `integer!` označují rozsah možných iterací;
    ** `paren!` - hodnota, která působí jako 	 <<Expression evaluation, únikový mechanizmus>> dialektu vyhodnocením obsaženého výrazu Red a pokračováním v parsování vstupu; některá klíčová slova Parse používají vrácené hodnoty z výraz ve shodě se svou vlastní sémantikou;
* Jakákoliv jiná literálová hodnota výše nezmíněná, jež se používá jak-je pro přímé porovnávání se vstupem.

NOTE: Parse je konsistentní s Redem v používání volných komparací pro porovnávání s literálovými hodnotami.

Každé pravidlo (rule) je charakterizováno podmínkami, při kterých pokročí vstupem a uspěje. Přehled pravidel dialektu Parse (jak vyhražená, tak klíčová slova) je tabelárně uveden níže.

.Přehled pravidel dialektu Parse.
[options="header" cols="2,3,2,2"]
|===
| Pravidlo | Categorie | Pokročí | Uspěje

| `case`
| <<Parsing modes>>
| Never
| Always

| `block!`
| <<Composition>>
| Depends
| Depends

| `word!`
| <<Composition>>
| Depends
| Depends

| Literal value
| <<Direct matching>>
| Depends
| Depends

| `lit-word!`
| <<Direct matching>>
| Depends
| Depends

| `lit-path!`
| <<Direct matching>>
| Depends
| Depends

| `datatype!`
| <<Direct matching>>
| Depends
| Depends

| `typeset!`
| <<Direct matching>>
| Depends
| Depends

| `bitset!`
| <<Direct matching>>
| Depends
| Depends

| `quote`
| <<Direct matching>>
| Depends
| Depends

| `skip`
| <<Direct matching>>
| Depends
| Depends

| `none`
| <<Direct matching>>
| Never
| Always

| `end`
| <<Direct matching>>
| Never
| Depends

| `opt`
| <<Look-ahead>>
| Depends
| Always

| `not`
| <<Look-ahead>>
| Never
| Depends

| `ahead`
| <<Look-ahead>>
| Never
| Depends

| `paren!`
| <<Expression evaluation>>
| Never
| Always

| `set-word!`
| <<Positioning>>
| Never
| Always

| `get-word!`
| <<Positioning>>
| Depends
| Always

| `integer!`
| <<Repetition>>
| Depends
| Depends

| `any`
| <<Repetition>>
| Depends
| Always

| `some`
| <<Repetition>>
| Depends
| Depends

| `while`
| <<Repetition>>
| Depends
| Always

| `to`
| <<Search>>
| Depends
| Depends

| `thru`
| <<Search>>
| Depends
| Depends

| `if`
| <<Control flow>>
| Never
| Depends

| `into`
| <<Control flow>>
| Depends
| Depends

| `fail`
| <<Control flow>>
| Never
| Never

| `break`
| <<Control flow>>
| Never
| Always

| `reject`
| <<Control flow>>
| Never
| Never

| `set`
| <<Extraction>>
| Depends
| Depends

| `copy`
| <<Extraction>>
| Depends
| Depends

| `collect`
| <<Extraction>>
| Depends
| Depends

| `keep`
| <<Extraction>>
| Depends
| Depends

| `remove`
| <<Modification>>
| Depends
| Depends

| `insert`
| <<Modification>>
| Always
| Always

| `change`
| <<Modification>>
| Depends
| Depends

|===

NOTE: Všechna pravidla v dále uvedených odstavcích se plně shodují se svými vstupy.

=== Skladba

Pravidla typu `block!` přímo  seskupují ostatní prvidla, jsouce prostředkem pro kombinaci.  Pravidla typu `word!` nepřímo odkazují na jiná pravidla, jsouce tak prostředkem pro abstrakci. Společně tvoří základ mluvnické skladby dialektu Parse.

Na strukturální úrovni je gramatika dialektu Parse složena ze _sekvencí_ a _alternativ_.

* Sekvence pravidel je skupina nula či více pravidel, individuelně ukončených _koncem_ pravidla. Tato sekvence je úspěšná, dospěje-li (postupně úspěšnou aplikací svých sub-pravidel) ke svému konci. V případě selhání některého sub-pravidla se proces parsování vrátí (backtracks) na počátek neúspěšné sekvence.
* Koncem sekvence pravidel je buď konec obalujícího bloku nebo _hraniční_ znak `|` (boundary word) alternativy.
* Alternativa je volitelná sekvence, kterou se Parse pokusí posoudit v případě, že předchozí (to jest před hranicí `|`) sekvence selže.

=== Přímé posouzení shody

Pravidla, popsaná v této části, přímo parsují (posuzují shodu) vstupní data a slouží jako základní stavební bloky pro sestavování složitějších pravidel.

==== Literálové hodnoty
Parse je konsistentní s Redem v používání volných komparací pro porovnávání s literálovými hodnotami.

Posouzení shody literálové hodnoty je úspěšné a vede k pokročení zadaným vstupem, je-li posuzovaná literálová hodnota totožná s hodnotou vstupu na aktuální pozici.

NOTE: Parse implicitně používá volnou komparaci pro ověření rovnosti. <<Case-sensitivity, Case-sensitivní režim>> vynucuje case-sensitivní porovnání (komparaci).

*Příklad*

----
parse [today is 5-September-2012 #"," 20.3 degrees/celsius][
    'yesterday 'was | 'today 'is 05/09/12 comma 2030e-2 ['degrees/fahrenheit | 'degrees/celsius]
]
----

NOTE: Pro porovnávání literálových hodnot, vymezených v dialektu Parse, se jako únikový mechanizmus používá klíčové slovo `quote`.

==== Datatype

Ověření shody podle datového typu je úspěšné a vede k pokročení vstupem, pokud je ověřovaná hodnota daného typu.

*Příklad*

----
parse [#a 'bird /is :the word][issue! lit-word! refinement! get-word! word!]
----

NOTE: Ověření shody podle datového typu není podporováno pro vstup typu `binary!` a `any-string!`.

==== Type set

Ověření shody podle typové sady je úspěšné a vede k pokročení vstupem, jestliže datový typ vstupní hodnoty patří k dané typové sadě (type set).

*Příklad*

----
banner: [
               |
              [_]
             [___]
            [_____]
    Red programming language
    https://www.red-lang.org
]

parse banner [default! series! any-block! any-list! all-word! any-word! any-type! any-string!]
----

NOTE: Ověření shody podle typové sady není podporováno pro vstup typu `binary!` a `any-string!`.

==== Character set

Je-li vstupní řada typu `any-string!` nebo `binary!` a vstupní
hodnota reprezentuje Unicode Code Point (UCP), který patří k dané sadě znaků, potom je ověření shody úspěšné a vede k pokročení vstupem. Ve všech ostatních případech je ověření shody neúspěšné.

Podrobnosti o vytvoření datové sady lze nalézt v 
https://doc.red-lang.org/en/datatypes/bitset.html[documentaci] k datovému typu `bitset!`.

*Příklad*

----
animal: charset [#"🦢" #"^(1F418)" 128007]
follow: charset "🚶👣🚸"

parse "👣 the white 🐇" [follow " the white " animal]
----

NOTE: Varianty _lowercase/uppercase_ téhož písmena mají různá UCP. Z toho vyplývá, že ověřování shody podle znakové sady je _case-sensitive_ bez ohledu na <<Parsing modes, režim parsování>>.

NOTE: Pro vstup typu `binary!` mají význam pouze hodnoty UCP menší než `255`, protože parsování v tomto režimu je _byte-granular_.

==== `quote`

Působí jako únikový (escape) mechanizmus ze sémantiky dialektu Parse a to literálovým ověřením shody následující hodnoty. Toto pravidlo je úspěšné a vede k posunu vstupem, jestliže je ověření shody úspěšné.

*Syntaxe*

----
quote <value>

<value> : literal value to match
----

*Příklad*

----
parse [[integer!] matches 20][quote [integer!] quote matches quote 20]
----

==== `skip`

Shoduje se s libobolnou hodnotou a pokročí vstupem. Selže pouze v případě, kdy je pozice vstupu na chvostu (tail), protože tam není co posuzovat.

*Příklad*

----
parse <💓> [skip | the beat]
----

==== `none`

Pravidlo _no-op_ nebo _catch-all_, vždy se shoduje a nikdy nevede k postupu vstupem.

*Příklad*

----
parse reduce [none none][none #[none] ['none | none] none! none]
----

==== `end`

Pravidlo je úspěšné, je-li pozice vstupu na jeho chvostu (tail) a nikdy nevede k postupu vstupem, protože již není kam se posouvat.

*Příklad*

----
parse [(＊◕ᴗ◕＊)][end | skip [skip | end]]
----

=== Look-ahead

Pravidla s _pohledem vpřed_ (look-ahead) nabízejí podrobnější nastavení ověřování shody, couvání (backtracking) a posunu vstupem.

==== `opt`

Volitelně posuzuje shodu s daným pravidlem, která vede či nevede k posunu vstupem. Pravidlo je vždy úspěšné (== true) bez ohledu na shodu.

*Syntaxe*

----
opt <rule>

<rule> : Parse rule (option) to match
----

*Příklad*

----
parse "maybe" [opt "or" "may" opt [#"b" #"e"] opt "not"]
----

==== `not`

Toto pravidlo (invertor) je úspěšné, jestliže zadané pravidlo selže a opačně. Nikdy nevede k posunu vstupem, bez ohledu na shodu či neshodu.

*Syntaxe*

----
not <rule>

<rule> : Parse rule to invert
----

*Příklad*

----
parse [panama][not 'man not ['plan | 'canal] not word! | skip]
----

==== `ahead`

Přednostně se shoduje s daným pravidlem. Selže v případě selhání pravidla, jinak je úspěšné bez posunu vstupem.

*Syntaxe*

----
ahead <rule>

<rule> : Parse rule to look ahead
----

*Příklad*

----
parse [great times ahead][ahead ['great 'times] 'great ahead ['times ahead word! 'ahead] 'times skip] 
----

=== Vyhodnocení výrazů

Pravidlo typu `paren!` obsahuje libovolný výraz Redu, který se v případě shody vyhodnotí. Toto pravidlo je vždy úspěšné ale nevede k postupu vstupem.

*Příklad*

----
parse [(did it match?)][
    block! (not matched)
    | (probe 'backtracked) quote (did it match?) (probe 'matched!)
]
----

=== Pozicování

Je možné označit aktuální pozici vstupu nebo _přetočit/rychle vpřed_ (rewind/fast-forward) na jinou pozici v téže vstupní řadě.

==== Označení

Pravidlo typu `set-word!` nastaví slovo k aktuální pozici vstupní řady. Je vždy úspěšné a nikdy nevede k postupu vstupem.

*Příklad*

----
check: quote (probe reduce [start :failed before after current end])
match: [before: 'this none after:]

parse [match this input][
    start: quote [false start] failed:
    | ahead [skip match] current: ['match 'this 'input] end: check
]
----

==== Přemístění

Pravidlo typu `get-word!` nastaví pozici vstupu na zmíněné slovo. Je vždy úspěšné a buď posouvá vpřed, zůstává stát nebo posouvá vzad - v závislosti na postavení markeru vzhledem k aktuální pozici vstupu.

*Příklad*

----
phrase: "and so on and so forth, 'til it gets boring"
goes: skip find phrase comma 2
end: tail phrase

parse phrase [again: "and" :again ['it | :goes] "until the" | :end]
----

NOTE: Přemístění pozice do jiné řady než vstupní není dovoleno.

=== Opakování

Pravidla níže popsaná působí při posouzení shody jako smyčky nebo iterátory buď určeným počtem opakování nebo až do dosažení neshody.

NOTE: Opakovací pravidla mají vlastnické chování a posoudí shodu co možná nejrozsáhlejšího vstupu.

==== Počet iterací

Provede posouzení shody s daným pravidlem zadaným počtem opakování. Je-li použita skladba range, je jako úspěšný akceptován libovolný počet shod v zadaném rozsahu.

*Syntaxe*

----
<count> <rule>
<count> <count> <rule>

<count> : non-negative integer! value or word! referring to such value
<rule>  : Parse rule to match a specified number of times
----

NOTE: Při použití skladby range, musí být první integer (spodní mez) menší nebo roven druhému celému číslu (horní mez).

*Příklad*

----
tuple:  [2 word!]
triple: [3 skip]
THX:    1138

parse [G A T T A C A][2 3 tuple triple | 0 thx [triple tuple] 1 tuple 0 triple]
----

==== Rekurze

Pravidla dialektu Parse lze rekurzivně skládat. Úroveň rekurze je limitována hloubkou interní paměti stack.

*Příklad*

----
ping: [none pong]
pong: [skip ping | end]

parse https://google.com ping
----

==== `any`

Porovná dané pravidlo nula či vícekrát (https://en.wikipedia.org/wiki/Kleene_star[Kleene star]), 
porovnávání končí při neúspěšném vyhodnocení shody nebo když nedojde k posunu vstupem. Pravidlo je vždy úspěšné.

*Syntaxe*

----
any <rule>

<rule> : Parse rule to match zero or more times
----

*Příklad*

----
letter: charset [#"a" - #"z" #"A" - #"Z"]
digit:  charset [#"0" - #"9"]

parse "Wow, 20 horses at 12,000 RPM!" [
    any "Twin ceramic rotor drives on each wheel!"
    "Wow" any [
        comma any space any digit
        space any letter any [not comma skip]
    ]
]
----

==== `some`

Porovná dané pravidlo nula či vícekrát (https://en.wikipedia.org/wiki/Kleene_star#Kleene_plus[Kleene plus]), porovnávání končí při neúspěšném vyhodnocení shody nebo když nedojde k posunu vstupem. Pravidlo je úspěšné při nalezení alespoň jedné shody.

*Syntaxe*

----
some <rule>

<rule> : Parse rule to match one or more times
----

*Příklad*

----
parse [
    skidamarink a dink a dink
    skidamarink a doo
][
    some [
        some none 'skidamarink
        [some ['a 'dink] | 'a 'doo]
    ]
]
----

==== `while`

Opakovaně porovnává dané pravidlo. Zastaví se pouze po selhání pravidla. Vždycky úspěšné.

CAUTION: Jestliže pravidlo neselže, uvízlo `while` v nekonečné smyčce.

*Syntaxe*

----
while <rule>

<rule> : Parse rule to match repeatedly
----

*Příklad*

----
parse [throw for a loop][
    while [word! | (print "failed and backtracked on matching the end") [not end] :explicit failure]
    | [while none] :infinite loop
]
----

=== Search

Pravidla search hledají určený vzor procházejíc vstupem až k výskytu shody.

==== `to`

Opakovaně se pokouší nalézt shodu s daným pravidlem až k dosažení úplné shody. Pokud řečené pravidlo selže, postoupí se vstupem o jeden element, což se počítá jako částečná shoda. V případě úplné shody je pozice vstupu nastavena do čela (head) posuzované části. Succeeds if rule match succeeded.

*Syntaxe*

----
to <rule>

<rule> : Parse rule (pattern to put input position at)
----

*Příklad*

----
matrix: #{
    416C6C20492073656520697320626C6F6E6465
    2C206272756E657474652C201337526564C0DE
}

parse matrix [
    to #{FACEFEED}
    | to #{1337} #{1337} start: to #{C0DE} end: (print to string! copy/part start end) 2 skip
]
----

==== `thru`

Opakovaně se pokouší nalézt shodu s daným pravidlem až k dosažení úplné shody. Pokud řečené pravidlo selže, postoupí se vstupem o jeden element, což se počítá jako částečná shoda. V případě úplné shody je pozice vstupu nastavena do chvostu (tail) posuzované části. Succeeds if rule match succeeded.

*Syntaxe*

----
thru <rule>

<rule> : Parse rule (pattern to advance thru)
----

*Příklad*

----
parse 'per/aspera/ad/astra [thru 'aspera ad: to 'astra thru end (probe ad)]
----

=== Řízený průběh

Řízený průběh ovlivňuje přímé provedení dialektu Parse vloženými podmínkami (regulovčíky): smyčkou (<<Repetition>>), změnou vstupu, předčasným ukončením a podmíněným porovnáním.

==== `if`

Podmíněná shoda - je úspěšná, když se daný výraz Redu vyhodnotí na true. Nikdy se neposune vstupem.

*Syntaxe*

----
if <expression>

<expression> : paren! expression
----

*Příklad*

----
parse [4 8 15 16 23 42][
    some [mark: skip if (any [even? probe mark/1 find [15 23] first mark])]
]
----

==== `into`

Je-li datový typ hodnoty na aktuální pozici vstupu podporován dialektem Parse, regulovčík `into` dočasně přemístí vstup k této hodnotě a posoudí ji z hlediska daného pravidla. Po skončeném posouzení se vstup vrátí do původní pozice a parsování pokračuje mimo shodující se hodnotu.

*Syntaxe*

----
into <rule>

<rule> : block! rule or word! that refers to such rule
----

*Příklad*

----
rule: [some [word! | into rule]]

parse [we [need [to [go [deeper]]]]] rule
----

==== `fail`

Tento regulovčík nutí přiložené pravidlo okamžitě selhat, pokud je umístěn na jeho konci. Nikdy neuspěje ani nepokročí vstupem.

*Příklad*

----
parse foo@bar.baz [["quux" | some fail | "foo"] "@" [fail] | thru "bar.baz"]
----

==== `break`

Nutí obklopující pravidlo `block!` okamžitě uspět. Ukončí průběh smyčky, je-li použito v nejvyšší úrovni <<Repetition, opakovacího>> pravidla. Vždy uspěje a nikdy nepokročí vstupem.

*Příklad*

----
parse [break away from everything][some [break] 0 1 [break] [2 [break] | 3 word! [break] skip]]
----

==== `reject`

Nutí obklopující pravidlo `block!` okamžitě selhat. Ukončí průběh smyčky, je-li použito v nejvyšší úrovni <<Repetition, opakovacího>> pravidla. Nikdy neuspěje a nepokročí vstupem.


*Příklad*

----
parse quote (I made a choice that I regret) [
    any [reject now] some [5 word! what: reject I see] is
    | :what 'I [[reject get] | skip]
]
----

=== Vyjmutí

Vyjímací (extraction) pravidla kopírují shodné hodnoty ze vstupních řad.

==== `set`

Přiřadí danému slovu první hodnotu ve shodující se části vstupu.

NOTE: Slovu je přiřazena hodnota `none`, pokud porovnávané pravidlo neposunulo pozici vstupu.

NOTE: Pro vstup typu `binary!` je slovo (word) nastaveno na hodnotu typu `integer!` mezi `0` a `255`.

*Syntaxe*

----
set <word> <rule>

<word> : word! value to set
<rule> : Parse rule
----


*Příklad*

----
parse "🍩🕳️" [set hole ahead [2 skip] set donut [to end]]
----

==== `copy`

Přiřadí danému slovu kopii shodující se části vstupu.

NOTE: Pokud porovnávané pravidlo nepokročilo vstupem, je slovu přiřazena prázdá řada (series) stejného typu jako vstup.

*Syntaxe*

----
copy <word> <rule>

<word> : word! value to set
<rule> : Parse rule
----

*Příklad*

----
parse [Huston do you copy?][2 word! copy Huston [2 word!] copy we opt "have a problem"]
----

==== `collect`

Shromáždí hodnoty, konformní s pravidly, které jsou označeny klíčovým slovem. Uspěje, uspěje-li dané pravidlo - postupujíc mimo konformní (matched) části vstupu.

Pravidlo `keep` uspěje, uspěje-li poskytnuté pravidlo - vkládajíc konformní hodnoty do bloku, vymezeného pravidlem `collect`.

NOTE: Použití klíčového slova `keep` bez souvislosti s pravidlem `collect` je zapovězeno.

*Syntaxe*

----
collect <rule>
collect set <word> <rule>
collect into <word> <rule>
collect after <word> <rule>

<word> : word! value
<rule> : Parse rule
----

Hodnoty jsou implicitně vkládány do chvostu (tail) bloku. Toto chování lze změnit níže popsanými volbami.

.`collect` options.
[[collect-options]]
[options="header" cols="1,9"]
|===
| Option | Description
| `set`
| Přiřadí danému slovu blok shromážděných (collected) hodnot.
| `into`
| Vloží shromážděné hodnoty do řady (series), označené slovem, přenese index řady do jejího čela.
| `after`
| Vloží shromážděné hodnoty do řady (series), označené slovem, přemístí index řady za vloženou část.
|===

* Je-li v kterémkoli pravidlu použit příkaz `collect` bez volby `into` či `after`, vráti funkce `parse` blok shromážděných hodnot (viz  <<Parsing modes>>); je-li příkaz `collect` použit s volbou `set`, vrátí funkce `parse` hodnotu typu `logic!` jako obvykle.
* První použití příkazu `collect` alokuje nový blok, který je vrácen funkcí `parse`, každé další použití příkazu `collect` alokuje blok na chvostu (tail) předchozího bloku; příkaz `collect` s volbou `into` či `after` použije již vytvořený buffer spíše než alokaci nového bloku.

Syntaxe pro `keep`:

----
keep <rule>
keep pick <rule>
keep <expression>
keep pick <expression>

<rule>       : Parse rule
<expression> : paren! expression
----

[[keep-options]]
* Jestliže porovnávané pravidlo nepokročilo vstupem, příkaz `keep` nic nezadrží.
* Jestliže pravidlo vyčlenilo jedinou hodnotu - tato je zadržena (is kept).
* Jestliže pravidlo vyčlenilo více hodnot, jsou tyto seskupeny do objektu stejného typu jako vstup; při volbě `pick` nejsou hodnoty seskupeny ale uchovány odděleně.
* Je-li příkaz `keep` použit s výrazem typu `paren!`, je výsledek jeho vyhodnocení uchován tak, jak je.

*Example*

----
fruit: charset [#"^(1F346)" - #"^(1F353)"]
plate: "tropical stuff: 🍌🍍 and other healthy food: 🥒🍅🥕"

parse plate [
    collect [
        keep (quote fruits:) collect [some [keep fruit | skip] fail]
        | keep (quote vegetables:) collect [to [#"🥒" | "Pickle Rick!"] keep pick [to end]]
    ]
]
----

=== Modifikace

Akce parse může modifikovat své vstupy vložením nových hodnot a odebrat či změnit odpovídající části vstupu.

==== `remove`

Buď odebere část vstupu, konformní s daným pravidlem nebo odebere vstup mezi aktuální a zadanou pozicí; zachová pozici na vstupu po jeho redukci.

NOTE: Odebírání hodnot je forward-consuming operace. Jinými slovy, počítá se jako shoda, přesto že nedojde k pokročení vstupem.

*Syntaxe*

----
remove <rule>
remove <word>

<rule> : Parse rule
<word> : input postion
----

*Příklad*

----
parse [remove me <and me also> "but leave me be"][some [remove word!] mark: to string! remove mark skip]
----

==== `insert`

Vloží literálovou hodnotu nebo výsledek vyhodnocení výrazu do aktuální pozice. Akce je vždy úspěšná a pokročí vstupem za místo vložení.

*Syntaxe*

----
insert <value>
insert <expression>

insert only <value>
insert only <expression>

<value>      : literal value
<expression> : paren! expression
----

Je-li literálová hodnota typu `word!`, použije se hodnota, na níž slovo odkazuje. Volba `only` prosadí sémantiku `insert/only`.

*Příklad*

----
parse [assembly][insert [some] skip insert (load "required") insert only [🏗️ 🧰👷]]
----

==== `change`

Mění konformní (matched) část vstupu na literálovou hodnotu nebo na výsledek vyhodnocení výrazu. Navíc, může změnit část vstupu mezi aktuální a označenou pozicí. Po provedené změně je akce považována za úspěšnou a pokročí vstupem za měněnou část.

*Syntaxe*

----
change <rule> <value>
change <rule> <expression>

change <word> <value>
change <word> <expression>

change only <rule> <value>
change only <rule> <expression>
change only <word> <value>
change only <word> <expression>

<rule>       : Parse rule
<word>       : input position
<value>      : literal value
<expression> : paren! expression
----

Je-li literálová hodnota typu `word!`, použije se její odkazovaná hodnota. Volba `only` prosadí sémantiku `change/only`.

*Příklad*

----
parse [some things never change][
    change none (quote and) 2 skip mark: to end change only mark [do]
]
----

== Události akce parse

Dialekt Parse je implementován jako pushdown automaton (PDA - využívající paměti typu stack); při každé změně stavu emituje _event_ (událost s hodnotou typu `word!`), která informuje uživatele o parsovacím procesu. Interakce mezi událostmi a interním stavem aktivity parse je dosaženo upřesněním `/trace` a callback funkcí (viz <<Extra funkce, další odstavec>>).

Níže je uveden seznam všech událostí s podmínkami, které je vyvolávají (štos = stack):

.Seznam událostí Parse.
[options="header" cols="1,4"]
|===
| Event | Description

| `push`
| Poté co je pravidlo vloženo na štos.

| `pop`
| Předtím než je pravidlo staženo ze štosu.

| `fetch`
| Předtím než je přiřazeno nové pravidlo.

| `match`
| Poté co byla nalezena shoda hodnoty s pravidlem.

| `iterate`
| Po započetí nového iteračního kola (viz <<Repetition>>).

| `paren`
| Po vyhodnocení výrazu typu `paren!`.

| `end`
| Po dosažení konce vstupu.

|===

== Extra funkce

Vstupním bodem do dialektu Parse je nativní funkce `parse`, která přijme vstupní objekt typu series! a blok s pravidly a podporuje dodatečná upřesnění (refinements): 

.`parse` refinements.
[options="header" cols="1,3"]
|===
| Refinement | Description
| `/case`
| Enable <<Parsing modes, case-sensitive mode>>.

| `/part`
| Limit parsing up to specified length or input position.

| `/trace`
| Interact with <<Parse events, event-based Parse API>> via provided _callback_.

|===

Při použití upřesnění `/trace` musí být deklarována callback funkce (hodnota typu `function!`) s následující specifikací:

.Callback function specification.
[options="header" cols="1,1,2"]
|===
| Argument | Type | Description

| `event`
| `word!`
| One of the <<Parse events>>.

| `match?`
| `logic!`
| Result of the last match.

| `rule`
| `block!`
| Current rule at current position.

| `input`
| `series!`
| Input series at current position.

| `stack`
| `block!`
| Internal Parse rules stack.

|===

Callback funkce musí vrátit hodnotu typu `logic!`, jež indikuje zda se má v parsování pokračovat (`true`) či nikoli (`false`). 

Za účelem ladění je implicitně poskytnuto zpětné volání (callback) `on-parse-event` a jeho `parse-trace` wrapper.

== Implementační poznámky

V této části jsou stručně zmíněny některé údaje o návrhu a implementaci dialektu Parse.

=== Volná komparace

Jak již bylo dříve zmíněno, Parse používá volnou komparaci (loose comparison) pro porovnávání literálových hodnot, což je konsistentní s Redem.

*Příklad*

----
parse [I'm 100% <sure>][quote :I'M 1.0 "sure"]
----

=== Prostý formát pravidla

Do jisté míry podporuje Parse prostý (flat) formát, při němž jsou pravidla psána lineárně jako výrazy s proměnnou aritou, spíše než s pomocí vnořených bloků.

*Příklad*

----
parse [on the count of three 1 2 3][collect set stash keep pick to ahead some 1 3 integer! remove any skip]
----

=== Otevřené problémy

Nevyřešené chyby a inkozistence návrhu, související s dialektem Parse jsou vypsány níže:

.Nevyřešené problémy.
[options="header" cols="2,6,1"]
|===
| Affected rules | Description | Tickets

| `change <position> <expression>`
| `word!` values are not used literally.
| https://github.com/red/red/issues/4200[#4200]

| `remove <position>`
| The case where position comes after the current one is not handled.
| https://github.com/red/red/issues/4199[#4199]

| `keep pick <expression>`
| Semantics is undefined.
| https://github.com/red/red/issues/4198[#4198]

| `collect into`
| Incorrect handling of series buffer.
| https://github.com/red/red/issues/4197[#4197]

| `into`
| It is possible to match series not supported by Parse.
| https://github.com/red/red/issues/4194[#4194]

| `break`, `reject`
| Preemptive break of <<Repetition>> rules.
| https://github.com/red/red/issues/4193[#4193]

| `insert <word>`
| The rule is not handled properly.
| https://github.com/red/red/issues/4153[#4153]

| `path!`, `remove`, `insert`, `change`
| Usage of `path!` literal value inside rules is forbidden, `path!` values are handled inconsistently by <<Modification>> rules. 
| https://github.com/red/red/issues/4101[#4101], https://github.com/red/red/issues/3528[#3528]

| `fail`, `break`, `reject`
| Design of some <<Control flow>> rules is not finalized.
| https://github.com/red/red/issues/3478[#3478], https://github.com/red/red/issues/3398[#3398]

| `lit-word!`, `lit-path!`
| Case-sensitive comparison is not handled properly.
| https://github.com/red/red/issues/3029[#3029]

|===
